######################
GStreamer 设计原则
######################

.. include:: ../links.ref
.. include:: ../tags.ref
.. include:: ../abbrs.ref

============ ==========================
**Abstract** GStreamer 设计原则
**Authors**  Walter Fan
**Status**   WIP as draft
**Updated**  |date|
============ ==========================

.. contents::
   :local:

设计原则
================

干净而强大的接口
----------------------------

GStreamer 为开发者提供了一个干净的接口:

* 应用程序开发者
  
  程序员可以使用一组广泛的强大工具来创建媒体管道，而无需编写任何代码。 执行复杂的媒体操作变得非常容易。

* 插件开发者

  插件开发者提供了一个干净简单的 API 来创建独立的插件。 集成了广泛的调试和跟踪机制。 
  GStreamer 还附带了一组广泛的真实可用的插件，可以作为示例。

Object oriented 面向对象的
----------------------------
* GStreamer 遵循 GObject (GLib 2.0 对象模型)。 熟悉 GLib 2.0 或 GTK+ 的程序员会对 GStreamer 感到很舒服。
* GStreamer 使用信号 (signals) 和对象属性的机制。
* 所有对象的各种属性和功能都可以在运行时查询。
* GStreamer 旨在在编程方法上与 GTK+ 类似。 这适用于对象模型、对象所有权、引用计数等。


可扩展
-----------------------------
* 所有 GStreamer 对象都可以使用 GObject 继承方法进行扩展。
* 所有插件都是动态加载的，并且可以独立扩展和升级。

允许仅二进制插件
-----------------------------
* 插件是在运行时加载的共享库。 由于插件的所有属性都可以使用 GObject 属性进行设置，因此不需要（实际上也没有办法）为插件安装任何头文件。
* 插件完全独立。 插件的所有相关方面都可以在运行时查询。


高性能
-----------------------------

高性能是通过以下方式获得的:

* 使用 GLib 的 GSlice 分配器
* 插件之间极其轻量级的链接。 数据可以以最小的开销传输管道。 插件之间的数据传递仅涉及典型管道中的指针取消引用。
* 提供一种直接作用于目标内存的机制。 例如，插件可以直接写入 X 服务器的共享内存空间。 缓冲区还可以指向任意内存，例如声卡的内部硬件缓冲区。
* 引用计数和写入时复制最大限度地减少了 memcpy 的使用。 子缓冲区有效地将缓冲区分割成可管理的部分。
* 专用流线程，由内核处理调度。
* 允许使用专门的插件进行硬件加速。
* 使用带有插件规范的插件注册表(plugin registry)，以便可以延迟插件加载，直到实际使用插件。


干净的核心/插件分离
--------------------------
GStreamer 的核心本质上是与媒体无关的。 它只知道字节和块，并且只包含基本元素。 
GStreamer 的核心功能甚至足以实现低级系统工具，例如 cp。

所有媒体处理功能均由核心外部的插件提供。 这些告诉核心如何处理特定类型的媒体。

提供编解码器实验框架
--------------------------
GStreamer 还希望成为一个简单的框架，编解码器开发人员可以在其中尝试不同的算法，从而加快开放和免费多媒体编解码器的开发，例如 Xiph.Org 基金会开发的编解码器 (例如 Theora 和 Vorbis).